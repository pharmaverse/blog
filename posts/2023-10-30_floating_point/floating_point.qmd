---
title: "Floating point"
author:
  - name: Stefan Thoma
description: "The untold story of how admiral deals with floating points."
date: "2023-10-30"
# please do not use any non-default categories.
# You can find the default categories in the repository README.md
categories: [admiral]
# feel free to change the image
image: "admiral.png"
---

<!--------------- typical setup ----------------->

```{r setup, include=FALSE}
long_slug <- "2023-10-30_floating_point"
# renv::use(lockfile = "renv.lock")
```

<!--------------- post begins here ----------------->
{{admiral}} recently ran into some trouble when dealing with floating point values, captured {by this thread on GitHub}(https://github.com/pharmaverse/admiral/pull/2060). 
This post gives a brief overview on floating point values, recaps the discussion on GitHub, and explains how {{admiral}} deals with floating point values.

## Floating point values

Floating point values are numeric objects representing numbers between integers, e.g. 0.5., 2.3, 3.1415, etc.
However, floating point numbers are not stored like integers, and most floating point numbers are approximations to the number they represent.
To see what value a floating point number is actually stored as, we can use the `format()` function:

```{r, echo=FALSE}
format(1.4, digits = 22)
```

This affects mathematical operations as well:

```{r}
0.1 + 0.2 == 0.3
```

If we look at the actually stored values, this makes sense:

```{r}
0.1 %>% format(digits = 22)
0.2 %>% format(digits = 22)

(0.1 + 0.2) %>% format(digits = 22)

0.3 %>% format(digits = 22)
```


::: callout-note
## Exact floating point values

There are also some floating point values which can be exactly represented. 
All these values can be represented as $\frac{x}{2^y}$, where x and y are integers.
For example, 0.5 is stored as $\frac{1}{2}$, 0.25 is stored as $\frac{1}{4}$, 0.125 is stored as $\frac{1}{8}$, etc.


```{r}
# simple examples
0.5 %>% format(digits = 22)
0.25 %>% format(digits = 22)
0.125 %>% format(digits = 22)
0.0625 %>% format(digits = 22)

# some weird values for x and y
(1121 / (2^9)) %>% format(digits = 22)
```

All floating point values are stored as $\frac{x}{2^y}$, where the outcome may be a very close approximation to the value they represent.

:::

## Issues arising

Gordon Miller stumbled upon this issue when he was creating a unit test for a function of {{admiral}}:

| The test is AVAL >= 1.1*ANRHI should give a value of "1" where AVAL = 110 and ANRHI = 100.
| I tried it separately and I also got 1.1*ANRHI not equal to 110 where ANRHI = 100.

Where ANRHI is the *analysis range upper limit* and AVAL is an *analysis value*. 

What happened here? 
Gordon Miller wanted to compute the *analysis range upper limit* plus 10% and compare it to the *analysis value*.
He expected the comparison to yield `TRUE` (or `1` if converted to `numeric`) as AVAL (110) should be exactly 1.1 * 100.
However, he multiplied an integer (100) with a floating point value (1.1).
And the result was not exactly 110, as 1.1 is not exactly represented as a floating point value.

```{r}
(1.1 * 100) %>% format(digits = 22)
1.1 * 100 == 110
```
On my machine, the result *is* actually larger than 110, while on Gordon Miller's machine the result was smaller than 110.
In {{admiral}}, we strive towards removing platform specific and unexpected behavior, so we had to find a way to solve the floating point issue.

## Potential solutions

A very crude option would be to round the result of the multiplication to the nearest integer.

```{r}
round(1.1 * 100) %>% format(digits = 22)
```
However, this does not work when the result is not an integer, i.e. the upper limit was 101 instead. 
We should then compare the analysis value to 101 * 1.1, which should be exactly 111.1.
We could try to round to the nearest decimal place, but that value would again be stored as a floating point value:

```{r}
(101 * 1.1) %>%
  round(digits = 1) %>%
  format(digits = 22)
```
A workaround would be to round to the nearest integer, and then divide by 10:

```{r}
(101 * 1.1) %>%
  round() %>%
  format(digits = 22)
```


However, this is not a good solution, as it is not clear how many decimal places to round to.







## Conclusion



<!--------------- appendices go here ----------------->

```{r, echo=FALSE}
source("appendix.R")
insert_appendix(
  repo_spec = "pharmaverse/blog",
  name = long_slug
)
```
