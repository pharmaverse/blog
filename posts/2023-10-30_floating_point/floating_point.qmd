---
title: "Floating point"
author:
  - name: Stefan Thoma
description: "The untold story of how admiral deals with floating points."
date: "2023-10-30"
# please do not use any non-default categories.
# You can find the default categories in the repository README.md
categories: [admiral]
# feel free to change the image
image: "admiral.png"
---

<!--------------- typical setup ----------------->

```{r setup, include=FALSE}
long_slug <- "2023-10-30_floating_point"
# renv::use(lockfile = "renv.lock")
```

<!--------------- post begins here ----------------->

{{admiral}} recently ran into some trouble when dealing with floating point values, captured [by this thread on GitHub](https://github.com/pharmaverse/admiral/pull/2060).
This post gives a brief overview on floating point values, recaps the discussion on GitHub, and explains how {{admiral}} deals with floating point values.

## Floating point values

Floating point values are numeric objects representing numbers between integers, e.g. 0.5., 2.3, 3.1415, etc.
However, floating point numbers are not stored like integers, and most floating point numbers are approximations to the number they represent.
To see what value a floating point number is actually stored as, we can use the `format()` function:

```{r, echo=FALSE, message = FALSE}
library(dplyr)
format(1.4, digits = 22)
```

This affects mathematical operations as well:

```{r}
0.1 + 0.2 == 0.3
```

If we look at the actually stored values, this makes sense:

```{r}
0.1 %>% format(digits = 22)
0.2 %>% format(digits = 22)

(0.1 + 0.2) %>% format(digits = 22)

0.3 %>% format(digits = 22)
```

Essentially: Avoid using exact comparators such as `==` and `>=` when comparing floating point values.

::: callout-note

## Exact floating point values

There are some floating point values which can be exactly represented.
All these values can be represented as $\frac{x}{2^y}$, where x and y are integers.
For example, 0.5 is stored as $\frac{1}{2}$, 0.25 is stored as $\frac{1}{4}$, 0.125 is stored as $\frac{1}{8}$, etc.

```{r}
# simple examples
0.5 %>% format(digits = 22)
0.25 %>% format(digits = 22)
0.125 %>% format(digits = 22)
0.0625 %>% format(digits = 22)

# some weird values for x and y
(1121 / (2^9)) %>% format(digits = 22)
```

All floating point values are stored as $\frac{x}{2^y}$, where the outcome may be a very close approximation to the value they represent.
:::

## Issues arising

Gordon Miller stumbled upon this issue when he was creating a unit test for a function in {{admiral}}.
This function made use of `atoxgr_criteria_ctcv5`, a `data-frame` object containing metadata on adverse events in cancer therapy. 
This is based on the Common Terminology Criteria for Adverse Events (CTCAE) of the US National Cancer Institute (NCI) is a classification system for adverse events in cancer therapy.
We can have a look here:

```{r}
# download old version of atoxgr_criteria_ctcv4 without the updated comparisons
load(url("https://github.com/pharmaverse/admiral/raw/d063939bf897939aa8de3c32c4ee1bdfef7280af/data/atoxgr_criteria_ctcv4.rda"))
# check it out.
atoxgr_criteria_ctcv4 %>% head() %>% select(TERM, Definition, GRADE_CRITERIA_CODE)
```



| The test is AVAL \>= 1.1\*ANRHI should give a value of "1" where AVAL = 110 and ANRHI = 100.
| I tried it separately and I also got 1.1\*ANRHI not equal to 110 where ANRHI = 100.

Where ANRHI is the *analysis range upper limit* and AVAL is an *analysis value*.

What happened here?
Gordon Miller wanted to compute the *analysis range upper limit* plus 10% and compare it to the *analysis value*.
He expected the comparison to yield `TRUE` (or `1` if converted to `numeric`) as AVAL (110) should be exactly 1.1 \* 100.
However, he multiplied an integer (100) with a floating point value (1.1).
And the result was not exactly 110, as 1.1 is not exactly represented as a floating point value.

```{r}
(1.1 * 100) %>% format(digits = 22)
1.1 * 100 == 110
```

On my machine, the result *is* actually larger than 110, while on Gordon Miller's machine the result was smaller than 110.
In {{admiral}}, we strive towards removing platform specific and unexpected behavior, so we had to find a way to solve the floating point issue.

## Potential solutions

A very crude option would be to round the result of the multiplication to the nearest integer.

```{r}
round(1.1 * 100) %>% format(digits = 22)
```

However, this does not work when the result is not an integer, i.e. the upper limit was 101 instead.
We should then compare the analysis value to 101 \* 1.1, which should be exactly 111.1.
We could try to round to the nearest decimal place, but that value would again be stored as a floating point value:

```{r}
(101 * 1.1) %>%
  round(digits = 1) %>%
  format(digits = 22)
```

A workaround would be to multiply both sides of the equation with 10, and then round to the next integer:

```{r}
(101 * 1.1 * 10) %>%
  round() %>%
  format(digits = 22)

(111.1 * 10) %>%
  round() %>% 
  format(digits = 22)
```

This is very awkward, as you don't know by how much you need to multiply each time, a very clunky solution.

Alternatively, we can compare the absolute value of the difference between the analysis value and the upper limit plus 10% to a very small number, e.g. 0.0000001:

```{r}

AVAL <- 111.1
COMP <- (101 * 1.1)

abs(AVAL - COMP) < 0.0000001
```

Comparing to a very small value is also how the `all.equal()` function works, which compares two numeric values and returns `TRUE` if they are equal within a tolerance.
By default the tolerance is around $1.5 * 10^{-8}$ but you can set it yourself to a lower value, e.g. machine tolerance `.Machine$double.eps` - the smallest positive floating-point number x such that 1 + x != 1.

```{r}
1 + .Machine$double.eps == 1

all.equal(AVAL, COMP, tolerance = .Machine$double.eps)
```

This would still be a little clunky for *greater than or equal to* comparisons: 

```{r}
all.equal(AVAL, COMP) | AVAL > COMP
# unfortunately, the all.equal() function does not return a FALSE if they are not the same:
all.equal(AVAL, COMP + 1)

```

For some reason, the value it returns is also not correct.

There is also a dplyr function called `near()` which does essentially the same thing as `all.equal()`:

```{r}
ANRHI <- 100
AVAL <- 110
(1.1*ANRHI) %>% format(digits = 22)
AVAL > 1.1*ANRHI | near(AVAL, 1.1*ANRHI)
```

By Gordon Miller suggested to replace the standard comparators with the following functions across {{admiral}}

| `base` | improved             |
|----------|----------------------|
| A \>= B  | A \> B \| near(A, B) |
| A \<= B  | A \< B \| near(A, B) |
| A == B   | near(A, B)           |
| A != B   | !near(A, B)           |
| A \> B   | A \> B & !near(A, B) |
| A \< B   | A \< B & !near(A, B) |


This would work perfectly fine, but especially for `case_when()` statements, it would add a lot of code-bloat.


::: callout-note
Although a minor issue, it looks like the `near()` function tests for absolute differences, while the `all.equal()` function tests for relative differences, as discussed in [this thread](https://github.com/tidyverse/dplyr/issues/6921):

```{r}
# very large values:
# when checking for absolute differences
near(1.1 * 100 * 10^6, 
     110 * 10^6)
# when checking for relative differences
all.equal(1.1 * 100 * 10^6, 
          110 * 10^6)

# as: 
(1.1 * 100 * 10^6) %>% format(digits = 22)
(110 * 10^6) %>% format(digits = 22)
```

:::

An even more elegant solution is implemented in the `fpCompare` package, which compares floating point numbers using custom infix operators: 


|         `base`            |`fpCompare`    |
|-------------------------|-------------|
|        A \>=  B            | A %>=% B	        |
|        A \<=  B            | A %<=% B	        |
|        A ==   B           | A %==% B	        |
|        A !=   B           | A %!=% B	        |
|        A \>   B            | A %>>% B	        |
|        A \<   B            | A %<<% B	        |


As an example to how this is implemented, we can have a look at the `fpCompare` source code for one of the operators:

```{r}
`%<=%` <- function(x, y) {
 (x < y + getOption("fpCompare.tolerance"))
}
```

Even if `y` is ever so slightly smaller than `x`, adding the tolerance to `y` will make the result larger than `x`, and the comparison will return TRUE.

```{r}
# we need to set the fpCompare.tolerance first, because we did not load the package:
options(fpCompare.tolerance = 1e-8)

(1.1 * 100) %<=% 110
```


```{r}
(1.1 * 100) %>% format(digits = 22)
(110) %>% format(digits = 22)
(1.1 * 100) %<=% 110
```


As long as {{admiral}} remains open source and free to use, using this package, or even reusing the code itself would be fine. 
Although this was *my* prefered option, we did not end up implementing it.
Instead, we made use of the `signif()` function, which rounds a number to a specified number of significant digits.
This way, we could use the regular infix operators and simply provide the number of significant digits we want to compare to:

```{r}
signif_dig <- 15
AVAL <- 110
signif(AVAL, signif_dig) == signif(ANRHI*1.1, signif_dig)


# as:
(ANRHI*1.1) %>% signif(signif_dig)  %>% format(digits = 22)
```


```{r}
atoxgr_criteria_ctcv5 %>% head() %>% select(TERM, Definition, GRADE_CRITERIA_CODE)
```


atoxgr_criteria_ctcv5

## Solution in {{admiral}}

## Conclusion

<!--------------- appendices go here ----------------->

```{r, echo=FALSE}
source("appendix.R")
insert_appendix(
  repo_spec = "pharmaverse/blog",
  name = long_slug
)
```
